Details of the state machine (new version, 09/03/2018)
======================================================

The state machine has been written to improve understanding and maintainability.
The main change is the recognition that, even for a Migration, most of the state
can be contained in the MigrationRequest.  This is because, even though many
GET MigrationRequests can point to a single Migration, for PUT MigrationRequests
there is a strict 1:1 mapping between the Migration and the MigrationRequest

Migrations now have only four states:

1. ON_DISK      (the filelist in the migration has been scheduled for upload but
                 not started)
2. PUTTING      (the filelist in the migration is being put on the external
                 storage)
2. ON_STORAGE   (the files in the filelist have been copied to the external
                 storage and deleted from the original storage)
3. FAILED       (something went wrong - record the failure reason in the
                 Migration request)

MigrationRequests now have many more states and handle all states of the data
transfer.  One task per operation.
MigrationRequests can now also be locked to prevent concurrent processes trying
to carry out two operations on a single Migration.

For PUT requests:
1.  PUT_START
2.  PUT_PACKING
3.  PUT_PENDING
4.  PUTTING
5.  VERIFY_PENDING
6.  VERIFY_GETTING
7.  VERIFYING
8.  PUT_TIDY
9.  PUT_COMPLETED

For GET requests
10. GET_START
11. GET_PENDING
12. GETTING
13. GET_UNPACK
14. GET_RESTORE
15. GET_TIDY
16. GET_COMPLETED

For DELETE requests
17. DELETE_START
18. DELETE_PENDING
19. DELETING
20. DELETE_TIDY
21. DELETE_COMPLETED

22. FAILED

There now follows a description of which operations are carried out when the
machine is in a particular start, which of the daemons carries out these
operations and the transition to the next stage in the state machine.
last_archive is used to keep track of which archive is being acted upon so
that if the script is interrupted it can be resumed from the last_archive.

1.  PUT START
=============
script: jdma_lock ->
tasks:
    lock the migration files (transfer ownership to root)
    create a filelist for directories
    create the Migration
    create the MigrationFiles
    create the MigrationArchives
    assign the MigrationFiles to the MigrationArchives bases on size so that no
    MigrationArchive size is less than the backends minimum object size
transition:
    PUT_START->PUT_PACKING
    ON_DISK->PUTTING

2.  PUT_PACKING
===============
script: jdma_pack -> (new script)
tasks:
    create the staging directory
    create the tarfile MigrationArchives in the staging directory and add the
      MigrationFiles to the MigrationArchives
    calculate the digests of the MigrationArchives
    set last_archive to 0
transition:
    PUT_PACKING->PUT_PENDING

3.  PUT_PENDING
===============
script: jdma_transfer ->
tasks:
    create an upload batch on the external storage backend
    set last_archive to 0
transition:
    PUT_PENDING->PUTTING

4.  PUTTING
===========
script: jdma_transfer ->
tasks:
    upload the MigrationArchives to the external storage backend
    close the upload batch on the external storage backend

4a. PUTTING
===========
script: jdma_monitor ->
tasks:
    poll for completion of upload
transition:
    PUTTING->VERIFY_PENDING

5.  VERIFY_PENDING
==================
script: jdma_transfer -> (move to jdma_verify?)
tasks:
    create the temporary verification directory
    create a download batch for the verification
    set last_archive to 0
transition:
    VERIFY_PENDING->VERIFY_GETTING

6.  VERIFY_GETTING
==================
script: jdma_transfer ->
tasks:
    download the MigrationArchives to the temporary verification directory
    close the download batch on the external storage
transition:
    none (next transition handled in jdma_monitor)

6a. VERIFY_GETTING
==================
script: jdma_monitor ->
tasks:
    poll for completion of the downloads
transition:
    VERIFY_GETTING->VERIFYING

7.  VERIFYING
=============
script: jdma_verify ->
tasks:
    verify the MigrationArchive files - make sure that the digest of the
    downloaded archive matches that of the digest calculated in PUT_PACKING
    set the Migration to ON_STORAGE
    set last_archive to 0
transition:
    VERIFYING->PUT_TIDY

8.  PUT_TIDY
=============
script: jdma_tidy ->
tasks:
    delete the staged archive tarfiles (created in PUT_PACKING)
    delete the verified downloaded archive tarfiles (create in VERIFY_GETTING)
    delete the original files if request_type == MIGRATE or
      restore permissions on original files if request_type == PUT
transition:
    PUT_TIDY->PUT_COMPLETED

9.  PUT_COMPLETED
=================
script: jdma_tidy ->
tasks:
    delete the MigrationRequest
    send the notification email that the Migration has completed successfully
    subtract the uploaded amount (sum of MigrationArchives) from the
      groupworkspace quota
transition:
    none, the MigrationRequest has been deleted
    PUTTING->ON_STORAGE

10. GET_START
=============
script: jdma_lock ->
tasks:
    create the target directory for the download
    create the download staging directory
transition:
    GET_START->GET_PENDING

11. GET_PENDING
================
script: jdma_transfer ->
tasks:
    create a download batch on the external storage
    set last_archive to 0
transition:
    GET_PENDING->GETTING

12. GETTING
===========
script: jdma_transfer ->
tasks:
    download the MigrationArchives to the download staging directory
    close the download batch on the external storage
    set last_archive to 0

12a.GETTING
===========
script: jdma_monitor ->
tasks:
    poll for completion of download
transition:
    GETTING->GET_UNPACKING

13. GET_UNPACKING
=================
script: jdma_pack -> (new script)
tasks:
    check the digest of the archive matches that in the database
    unpack the tar archives from the download staging directory to the target
      directory
    set last_archive to 0
transition:
    GET_UNPACKING->GET_RESTORE

14. GET_RESTORE
===============
script: jdma_transfer -> (or jdma_packing? or a new script)
tasks:
    restore the uid, gid and permissions to the files unpacked from the tar
      archive
transition:
    GET_RESTORE->GET_TIDY

15. GET_TIDY
============
script: jdma_tidy ->
tasks:
    delete the files from the download staging directory
transition:
    GET_TIDY->GET_COMPLETED

16. GET_COMPLETED
=================
script: jdma_tidy ->
tasks:
    delete the MigrationRequest
    send the email notification informing the user that the Migration has been
     downloaded successfully
transition:
    none, the MigrationRequest has been deleted

17. DELETE_START
================
script: jdma_lock ->
tasks:
    lock the Migration that is going to be deleted, so no further processing will
     occur
transition:
    DELETE_START->DELETE_PENDING

18. DELETE_PENDING
==================
script: jdma_transfer ->
tasks:
    create a delete batch on the external storage
    set last_archive to 0
transition:
    DELETE_PENDING->DELETING

19. DELETING
============
script: jdma_transfer ->
tasks:
    delete the MigrationArchives from the external storage, one by one
     if migration.stage > PUT_PACKING
    close the delete batch
transition:
    none - the next transition is handled in jdma_monitor

19a. DELETING
script: jdma_monitor ->
tasks:
    poll for completion of delete
transition:
    DELETING->DELETE_TIDY

20. DELETE_TIDY
===============
script: jdma_tidy ->
tasks:
    delete any container for the batch on the external storage (e.g. bucket)
    delete the archive files if MigrationRequest exists and stage > PUT_PACKING
    delete the verify files if MigrationRequest exists and stage > VERIFY_PENDING
    restore permissions on original files if request_type == PUT and / or
     stage < PUT_TIDY

transition:
    DELETE_TIDY->DELETE_COMPLETED

21. DELETE_COMPLETED
====================
script: jdma_tidy ->
tasks:
    send the email notification informing the user that the Migration has been
     deleted successfully
    delete the Migration (as the delete mode is set to CASCADE in the Migration
     model, this should delete the MigrationRequest, the MigrationArchives and
     the MigrationFiles associated with the Migration)
    update the quota for the backend storage (add back the used space)
    delete the DELETE MigrationRequest
transition:
    none, the MigrationRequest has been deleted

--------------------------------------------------------------------------------
To test the Migrations, in development / test mode:

First become root: `sudo su`
Then activate the virtual env by invoking:
`source /home/vagrant/JDMA/venv/bin/activate`

Then navigate to the JDMA source directory: `cd /Coding/django-jdma_control`

Then run the scripts using ./manage.py runscript <script name>

In the test mode run the scripts in this order:

(To PUT or MIGRATE data)
(should we have a JDMA transition daemon?)
                    MigrationRequest.stage
                    ----------------------
1.  jdma_lock       PUT_START->PUT_PACKING
3.  jdma_pack       PUT_PACKING->PUT_PENDING
2.  jdma_transfer   PUT_PENDING->PUTTING
4.  jdma_transfer   (no state transition)
5.  jdma_monitor    PUTTING->VERIFY_PENDING
6.  jdma_transfer   VERIFY_PENDING->VERIFY_GETTING
7.  jdma_transfer   (no state transition)
8.  jdma_monitor    VERIFY_GETTING->VERIFYING
9.  jdma_verify     VERIFYING->PUT_TIDY
10. jdma_tidy       PUT_TIDY->PUT_COMPLETED
11. jdma_tidy       PUT_COMPLETED->deleted


(To GET data)
                    MigrationRequest.stage
                    -----------------------
1.  jdma_lock        GET_START->GET_PENDING
2.  jdma_transfer    GET_PENDING->GETTING
3.  jdma_transfer    (no state transition)
4.  jdma_monitor     GETTING->GET_UNPACK
5   jdma_pack        GET_UNPACK->GET_RESTORE
6.  jdma_transfer    GET_RESTORE->GET_TIDY
7.  jdma_tidy        GET_TIDY->GET_COMPLETED
8.  jdma_tidy        GET_COMPLETED->deleted


(To DELETE data)
                    MigrationRequest.stage
                    -----------------------
1.  jdma_lock        DELETE_START->DELETE_PENDING
2.  jdma_transfer    DELETE_PENDING->DELETING
3.  jdma_transfer    (no state transition)
4.  jdma_monitor     DELETING->DELETE_TIDY
5.  jdma_tidy        DELETE_TIDY->DELETE_COMPLETED
6.  jdma_tidy        DELETE_COMPLETED->deleted

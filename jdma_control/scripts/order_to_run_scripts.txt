Details of the state machine (new version, 09/03/2018)
======================================================

The state machine has been written to improve understanding and maintainability.
The main change is the recognition that, even for a Migration, most of the state
can be contained in the MigrationRequest.  This is because, even though many
GET MigrationRequests can point to a single Migration, for PUT MigrationRequests
there is a strict 1:1 mapping between the Migration and the MigrationRequest

Migrations now have only four states:

1. ON_DISK      (the filelist in the migration has been scheduled for upload but
                 not started)
2. PUTTING      (the filelist in the migration is being put on the external
                 storage)
2. ON_STORAGE   (the files in the filelist have been copied to the external
                 storage and deleted from the original storage)
3. FAILED       (something went wrong - record the failure reason in the
                 Migration request)

MigrationRequests now have many more states and handle all states of the data
transfer.  One task per operation.
MigrationRequests can now also be locked to prevent concurrent processes trying
to carry out two operations on a single Migration.

For PUT requests:
1.  PUT_START
2.  PUT_PENDING
3.  PUT_PACK
4.  PUTTING
5.  VERIFY_PENDING
6.  VERIFY_GETTING
7.  VERIFYING
8.  PUT_TIDY
9.  PUT_COMPLETED

For GET requests
10. GET_START
11. GET_PENDING
12. GETTING
13. GET_UNPACK
14. GET_RESTORE
15. GET_TIDY
16. GET_COMPLETED

17. FAILED

There now follows a description of which operations are carried out when the
machine is in a particular start, which of the daemons carries out these
operations and the transition to the next stage in the state machine.
last_archive is used to keep track of which archive is being acted upon so
that if the script is interrupted it can be resumed from the last_archive.

1.  PUT START
=============
script: jdma_lock ->
tasks:
    lock the migration files (transfer ownership to root)
    create a filelist for directories
    create the MigrationFiles
    create the MigrationArchives
    assign the MigrationFiles to the MigrationArchives bases on size so that no
    MigrationArchive size is less than the backends minimum object size
transition:
    PUT_START->PUT_PENDING
    ON_DISK->PUTTING

2.  PUT_PENDING
===============
script: jdma_transfer ->
tasks:
    create an upload batch on the external storage backend
    set last_archive to 0
transition:
    PUT_PENDING->PUT_PACKING

3.  PUT_PACKING
===============
script: jdma_pack -> (new script)
tasks:
    create the staging directory
    create the tarfile MigrationArchives in the staging directory and add the
      MigrationFiles to the MigrationArchives
    calculate the digests of the MigrationArchives
    set last_archive to 0
transition:
    PUT_PACKING->PUTTING

4.  PUTTING
===========
script: jdma_transfer ->
tasks:
    upload the MigrationArchives to the external storage backend
    close the upload batch on the external storage backend

4a. PUTTING
===========
script: jdma_monitor ->
tasks:
    poll for completion of upload
transition:
    PUTTING->VERIFY_PENDING

5.  VERIFY_PENDING
==================
script: jdma_transfer -> (move to jdma_verify?)
tasks:
    create the temporary verification directory
    create a download batch for the verification
    set last_archive to 0
transition:
    VERIFY_PENDING->VERIFY_GETTING

6.  VERIFY_GETTING
==================
script: jdma_transfer ->
tasks:
    download the MigrationArchives to the temporary verification directory
transition:
    none (next transition handled in jdma_monitor)

6a. VERIFY_GETTING
==================
script: jdma_monitor ->
tasks:
    poll for completion of the downloads
transition:
    VERIFY_GETTING->VERIFYING

7.  VERIFYING
=============
script: jdma_verify ->
tasks:
    verify the MigrationArchive files - make sure that the digest of the
    downloaded archive matches that of the digest calculated in PUT_PACKING
    set the Migration to ON_STORAGE
    set last_archive to 0
transition:
    VERIFYING->PUT_TIDY

8.  PUT_TIDY
=============
script: jdma_tidy ->
tasks:
    delete the staged archive tarfiles (created in PUT_PACKING)
    delete the verified downloaded archive tarfiles (create in VERIFY_GETTING)
    delete the original files if request_type == MIGRATE or
      restore permissions on original files if request_type == PUT
transition:
    PUT_TIDY->PUT_COMPLETED

9.  PUT_COMPLETED
=================
script: jdma_tidy ->
tasks:
    delete the MigrationRequest
    send the notification email that the Migration has completed successfully
    subtract the uploaded amount (sum of MigrationArchives) from the
      groupworkspace quota
transition:
    none, the MigrationRequest has been deleted
    PUTTING->ON_STORAGE

10. GET_START
=============
script: jdma_lock ->
tasks:
    create the target directory for the download
    create the download staging directory
transition:
    GET_START->GET_PENDING

11. GET_PENDING
================
script: jdma_transfer ->
tasks:
    create a download batch on the external storage
    set last_archive to 0
transition:
    GET_PENDING->GETTING

12. GETTING
===========
script: jdma_transfer ->
tasks:
    download the MigrationArchives to the download staging directory
    set last_archive to 0

12a.GETTING
===========
script: jdma_monitor ->
tasks:
    poll for completion of download
transition:
    GETTING->GET_UNPACKING

13. GET_UNPACKING
=================
script: jdma_pack -> (new script)
tasks:
    check the digest of the archive matches that in the database
    unpack the tar archives from the download staging directory to the target
      directory
    set last_archive to 0
transition:
    GET_UNPACKING->GET_RESTORE

14. GET_RESTORE
===============
script: jdma_transfer -> (or jdma_packing? or a new script)
tasks:
    restore the uid, gid and permissions to the files unpacked from the tar
      archive
transition:
    GET_RESTORE->GET_TIDY

15. GET_TIDY
============
script: jdma_tidy ->
tasks:
    delete the files from the download staging directory
transition:
    GET_TIDY->GET_COMPLETED

16. GET_COMPLETED
=================
script: jdma_tidy ->
tasks:
    delete the MigrationRequest
    send the email notification informing the user that the Migration has been
    downloaded successfully
transition:
    none, the MigrationRequest has been deleted

--------------------------------------------------------------------------------
To test the Migrations, in development / test mode:

First become root: `sudo su`
Then activate the virtual env by invoking:
`source /home/vagrant/JDMA/venv/bin/activate`

Then navigate to the JDMA source directory: `cd /Coding/django-jdma_control`

Then run the scripts using ./manage.py runscript <script name>

In the test mode run the scripts in this order:

(To PUT or MIGRATE data)
(should we have a JDMA transition daemon?)
                    MigrationRequest.stage
                    ----------------------
1.  jdma_lock       PUT_START->PUT_PENDING
2.  jdma_transfer   PUT_PENDING->PUT_PACK
3.  jdma_pack       PUT_PACK->PUTTING
4.  jdma_transfer   (no state transition)
5.  jdma_monitor    PUTTING->VERIFY_PENDING
6.  jdma_transfer   VERIFY_PENDING->VERIFY_GETTING
7.  jdma_transfer   (no state transition)
8.  jdma_monitor    VERIFY_GETTING->VERIFYING
9.  jdma_verify     VERIFYING->PUT_TIDY
10. jdma_tidy       PUT_TIDY->PUT_COMPLETED
11. jdma_tidy       PUT_COMPLETED->deleted


(To GET data)
                    MigrationRequest.stage
                    -----------------------
1.  jdma_lock        GET_START->GET_PENDING
2.  jdma_transfer    GET_PENDING->GETTING
3.  jdma_transfer    (no state transition)
4.  jdma_monitor     GETTING->GET_UNPACK
5   jdma_pack        GET_UNPACK->GET_RESTORE
6.  jdma_transfer    GET_RESTORE->GET_TIDY
7.  jdma_tidy        GET_TIDY->GET_COMPLETED
8.  jdma_tidy        GET_COMPLETED->deleted


In the deployment mode the scripts will be run by cron
